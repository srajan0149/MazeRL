<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Maze RL — Explore & Final Path (Q-Learning)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:#f4f7fb; color:#0f172a; margin:12px; }
  .wrap { max-width:1100px; margin:0 auto; }
  header { display:flex; gap:12px; align-items:center; margin-bottom:10px; }
  h1 { font-size:18px; margin:0; }
  .controls { display:flex; flex-wrap:wrap; gap:8px; background: #fff; padding:10px; border-radius:10px; box-shadow: 0 6px 18px rgba(2,6,23,0.06); }
  label { font-size:13px; color:#475569; display:flex; gap:6px; align-items:center; }
  button { padding:8px 10px; border-radius:8px; border:0; cursor:pointer; background:#2563eb; color:#fff; font-weight:600; }
  button.ghost { background:#eef2ff; color:#0f172a; border:1px solid #e6eefc; }
  button.warn { background:#ef4444; }
  canvas { background: linear-gradient(#ffffff,#f8fbff); border-radius:8px; display:block; margin-top:12px; cursor:crosshair; }
  .sidebar { margin-left:12px; width:300px; }
  .layout { display:flex; gap:12px; }
  .small { font-size:13px; color:#475569; }
  .legend { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
  .sw { width:18px; height:18px; border-radius:4px; }
  .info { background:#fff; padding:10px; border-radius:8px; box-shadow:0 6px 18px rgba(2,6,23,0.04); }
  textarea { width:100%; height:110px; margin-top:8px; border-radius:6px; padding:6px; border:1px solid #eef2ff; font-family:monospace; font-size:12px; }
  ul { padding-left:16px; margin:6px 0; color:#374151; }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Maze RL — Visual Exploration & Final Path (Q-Learning)</h1>
    <div class="small">Left-click toggle wall · Shift+Left-click set goal · Right-click set start</div>
  </header>

  <div class="controls">
    <label>Grid <input id="gridSize" type="number" value="16" min="6" max="40" style="width:64px"/></label>
    <label>Cell px <input id="cellPx" type="number" value="36" min="12" max="72" style="width:64px"/></label>

    <label>α <input id="alpha" type="range" min="0.01" max="1" step="0.01" value="0.5"/></label>
    <label>γ <input id="gamma" type="range" min="0" max="0.99" step="0.01" value="0.95"/></label>
    <label>ε <input id="epsilon" type="range" min="0" max="1" step="0.01" value="0.4"/></label>

    <label>Episodes <input id="episodes" type="number" value="800" min="1" style="width:80px"/></label>

    <button id="newGrid" class="ghost">New Grid</button>
    <button id="clearAll" class="ghost">Clear Walls/Goals</button>

    <button id="start">Start Train</button>
    <button id="pause" class="ghost">Pause</button>
    <button id="step" class="ghost">Step Ep</button>
    <button id="resetQ" class="ghost">Reset Q</button>
    <button id="showPath" class="ghost">Show Final Path</button>
    <button id="copyQ" class="ghost">Copy Q</button>
    <button id="pasteQ" class="ghost">Paste Q</button>
  </div>

  <div class="layout" style="margin-top:12px;">
    <div style="flex:1">
      <canvas id="canvas"></canvas>
      <div style="display:flex;gap:12px;margin-top:6px;align-items:center;">
        <div class="small">Episode: <span id="episode">0</span></div>
        <div class="small">Step (current ep): <span id="stepCount">0</span></div>
        <div class="small">Last reward: <span id="lastReward">0</span></div>
        <div class="small">Visited cells: <span id="visitedCount">0</span></div>
      </div>
    </div>

    <div class="sidebar">
      <div class="info">
        <div class="small"><strong>Legend</strong></div>
        <div class="legend">
          <div class="sw" style="background:#ffffff;border:1px solid #e6eefc"></div><div class="small">Free</div>
          <div class="sw" style="background:#111827"></div><div class="small">Wall</div>
          <div class="sw" style="background:#f59e0b"></div><div class="small">Goal (treasure)</div>
          <div class="sw" style="background:#06b6d4"></div><div class="small">Start (agent)</div>
          <div class="sw" style="background:rgba(99,102,241,0.9)"></div><div class="small">Final path</div>
        </div>

        <div style="height:10px"></div>
        <div class="small"><strong>How to use</strong>
          <ul>
            <li>Click to add walls. Shift+click to set goal. Right-click sets start.</li>
            <li>Start training — the particle will move each episode and visit heat expands.</li>
            <li>After training press <em>Show Final Path</em> to overlay greedy route.</li>
            <li>Use <strong>Reset Q</strong> to clear learned Q & counts (you can start again immediately).</li>
          </ul>
        </div>

        <div style="height:8px"></div>
        <div class="small">Q-table JSON (copy/paste)</div>
        <textarea id="qText" placeholder="Press Copy Q to capture current Q-table JSON"></textarea>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- DOM ----------
  const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
  const gridSizeInp = document.getElementById('gridSize'), cellPxInp = document.getElementById('cellPx');
  const newGridBtn = document.getElementById('newGrid'), clearAllBtn = document.getElementById('clearAll');
  const alphaEl = document.getElementById('alpha'), gammaEl = document.getElementById('gamma'), epsilonEl = document.getElementById('epsilon');
  const episodesEl = document.getElementById('episodes');
  const startBtn = document.getElementById('start'), pauseBtn = document.getElementById('pause'), stepBtn = document.getElementById('step');
  const resetQBtn = document.getElementById('resetQ'), showPathBtn = document.getElementById('showPath');
  const copyQBtn = document.getElementById('copyQ'), pasteQBtn = document.getElementById('pasteQ');
  const qText = document.getElementById('qText');
  const epSpan = document.getElementById('episode'), stepSpan = document.getElementById('stepCount'), lastRewardSpan = document.getElementById('lastReward');
  const visitedSpan = document.getElementById('visitedCount');

  // ---------- settings & state ----------
  let rows = parseInt(gridSizeInp.value), cols = rows;
  let cellPx = parseInt(cellPxInp.value);
  const ACTIONS = [
    {dx:0, dy:-1, name:'U'},
    {dx:1, dy:0,  name:'R'},
    {dx:0, dy:1,  name:'D'},
    {dx:-1,dy:0,  name:'L'}
  ];

  let grid = []; // 0 free, 1 wall, 2 goal
  let start = null; // {r,c}
  let goal = null;  // {r,c}
  let visitCount = []; // rows x cols
  let qTable = {}; // key "r,c" -> [4]
  let running = false, paused = false;
  let episode = 0, stepCount = 0;
  let lastReward = 0;
  let visitedCellsSet = new Set();
  let showFinalPath = []; // array of coords for final overlay
  let animateSpeed = 25; // ms per agent step during animation

  // ---------- helpers ----------
  function inBounds(r,c){ return r>=0 && r<rows && c>=0 && c<cols; }
  function keyOf(r,c){ return r + ',' + c; }
  function ensureQ(r,c){ const k=keyOf(r,c); if(!qTable[k]) qTable[k] = [0,0,0,0]; }
  function bestActionIndex(r,c){ ensureQ(r,c); const arr=qTable[keyOf(r,c)]; let best=0; for(let i=1;i<4;i++) if(arr[i]>arr[best]) best=i; return best; }

  // init new grid (random-ish walls + a goal)
  function initGrid(n=rows){
    rows = cols = parseInt(n);
    grid = new Array(rows); visitCount = new Array(rows);
    for(let r=0;r<rows;r++){ grid[r] = new Array(cols).fill(0); visitCount[r] = new Array(cols).fill(0); }
    // random walls
    for(let k=0;k<Math.floor(rows*cols*0.08);k++){
      const r = Math.floor(Math.random()*rows), c = Math.floor(Math.random()*cols);
      grid[r][c] = 1;
    }
    // place goal(s)
    let gr, gc;
    do{ gr = Math.floor(Math.random()*rows); gc = Math.floor(Math.random()*cols);} while(grid[gr][gc] === 1);
    grid[gr][gc] = 2; goal = {r:gr,c:gc};

    // place start not on wall/goal (center-ish)
    let sr=Math.floor(rows/2), sc=Math.floor(cols/2);
    if(grid[sr][sc] !== 0){
      for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ if(grid[r][c]===0){ sr=r; sc=c; break; } } }
    }
    start = {r:sr,c:sc};
    qTable = {}; visitedCellsSet.clear(); episode = 0; stepCount = 0; lastReward = 0; showFinalPath = [];
    resizeCanvas();
    render();
  }

  function resizeCanvas(){
    cellPx = parseInt(cellPxInp.value);
    canvas.width = cols * cellPx;
    canvas.height = rows * cellPx;
  }

  // environment step
  function stepEnv(r,c,aIdx){
    const a = ACTIONS[aIdx];
    const nr = r + a.dy, nc = c + a.dx;
    if(!inBounds(nr,nc) || grid[nr][nc] === 1){
      // bumped into wall: negative reward, stay in place
      return {r,c,reward:-0.6,done:false};
    }
    if(grid[nr][nc] === 2){
      // hit goal -> reward and episode end
      return {r:nr,c:nc,reward:10,done:true};
    }
    // ordinary move small penalty to encourage shorter paths
    return {r:nr,c:nc,reward:-0.04,done:false};
  }

  // Q-learning update
  function qUpdateQL(sR,sC,aIdx,reward,nR,nC,done){
    ensureQ(sR,sC); ensureQ(nR,nC);
    const qsa = qTable[keyOf(sR,sC)][aIdx];
    const alpha = parseFloat(alphaEl.value), gamma = parseFloat(gammaEl.value);
    const maxNext = done ? 0 : Math.max(...qTable[keyOf(nR,nC)]);
    qTable[keyOf(sR,sC)][aIdx] = qsa + alpha*(reward + gamma*maxNext - qsa);
  }

  // epsilon-greedy
  function chooseAction(r,c,epsilon){
    ensureQ(r,c);
    if(Math.random() < epsilon) return Math.floor(Math.random()*4);
    return bestActionIndex(r,c);
  }

  // run one episode but animate agent moves; returns a Promise that resolves when episode ends
  function runEpisodeAnimated(maxSteps=800){
    return new Promise(resolve => {
      let r = start.r, c = start.c;
      let steps = 0;
      // make a local epsilon but read from slider at episode start (we won't modify slider here)
      let epsilon = parseFloat(epsilonEl.value);
      let path = []; // store path for visual trail this episode
      function stepOnce(){
        // If training globally stopped, finish the episode immediately
        if(!running){
          resolve({ended:false, steps});
          return;
        }
        if(paused){ setTimeout(stepOnce, 60); return; }
        const aIdx = chooseAction(r,c,epsilon);
        const res = stepEnv(r,c,aIdx);
        qUpdateQL(r,c,aIdx,res.reward,res.r,res.c,res.done);
        // update visitation
        visitCount[res.r][res.c] += 1;
        visitedCellsSet.add(keyOf(res.r,res.c));
        r = res.r; c = res.c;
        path.push({r,c});
        stepCount++; lastReward = res.reward;
        render(path);
        if(res.done || ++steps >= maxSteps){
          // small epsilon decay but do not write into slider directly; instead update slider gently
          let eps = parseFloat(epsilonEl.value);
          eps = Math.max(0.02, eps * 0.995);
          epsilonEl.value = eps.toFixed(3);
          episode++; epSpan.textContent = episode;
          lastRewardSpan.textContent = lastReward.toFixed(2);
          visitedSpan.textContent = visitedCellsSet.size;
          // reset stepCount view for next episode
          stepSpan.textContent = 0;
          resolve({ended:res.done, steps});
          return;
        }
        stepSpan.textContent = steps;
        setTimeout(stepOnce, animateSpeed);
      }
      stepOnce();
    });
  }

  // Training loop: runs episodes sequentially (animates each)
  async function startTraining(){
    if(running) return;
    // ensure any previous run is fully stopped
    running = true; paused = false;
    startBtn.textContent = 'Stop';
    startBtn.disabled = false; // enabled so user can stop
    pauseBtn.textContent='Pause';
    const total = parseInt(episodesEl.value) || 1;
    for(let i=0;i<total;i++){
      if(!running) break; // allow stop
      await runEpisodeAnimated(1200);
      if(!running) break;
    }
    // finished naturally or stopped
    running = false;
    paused = false;
    startBtn.textContent = 'Start Train';
    startBtn.disabled = false;
    pauseBtn.textContent = 'Pause';
  }

  function stopTraining(){
    // this will cause runEpisodeAnimated to resolve quickly
    running = false;
    paused = false;
    startBtn.textContent = 'Start Train';
    startBtn.disabled = false;
    pauseBtn.textContent = 'Pause';
  }

  // Step one episode without entering full run loop
  async function stepEpisode(){
    if(running) return;
    paused = false;
    const res = await runEpisodeAnimated(1200);
    // not changing running (it's false)
  }

  // Compute greedy final path from start following best actions until goal or loop/limit
  function computeFinalPath(limit=rows*cols*5){
    const path = [];
    let r = start.r, c = start.c;
    const seen = new Set();
    for(let k=0;k<limit;k++){
      const kkey = keyOf(r,c);
      if(seen.has(kkey)) break;
      seen.add(kkey);
      path.push({r,c});
      if(grid[r][c] === 2) break;
      if(!qTable[kkey]) break;
      const a = bestActionIndex(r,c);
      const res = stepEnv(r,c,a);
      r = res.r; c = res.c;
      if(res.done){ path.push({r,c}); break; }
    }
    return path;
  }

  // ---------- rendering ----------
  function render(currentPath=[]){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // cells
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = c*cellPx, y = r*cellPx;
        // base floor
        ctx.fillStyle = '#ffffff'; ctx.fillRect(x,y,cellPx,cellPx);
        // walls
        if(grid[r][c] === 1){ ctx.fillStyle = '#111827'; ctx.fillRect(x,y,cellPx,cellPx); }
        // draw visit heat if visited >0
        const v = visitCount[r][c] || 0;
        if(v>0){
          const alpha = Math.min(0.9, 0.08 * Math.log(v+1));
          ctx.fillStyle = `rgba(239,68,68,${alpha})`; // red-ish heat
          ctx.fillRect(x,y,cellPx,cellPx);
        }
        // goal icon
        if(grid[r][c] === 2){
          ctx.fillStyle = '#f59e0b';
          ctx.beginPath();
          ctx.ellipse(x+cellPx*0.5, y+cellPx*0.42, cellPx*0.26, cellPx*0.26, 0, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle = '#fff'; ctx.font = `${Math.max(12,cellPx*0.18)}px sans-serif`; ctx.textAlign='center';
          ctx.fillText('★', x+cellPx*0.5, y+cellPx*0.42);
        }
        // cell border
        ctx.strokeStyle = '#e6eefc'; ctx.strokeRect(x,y,cellPx,cellPx);
        // small best-action arrow if q exists
        const k = keyOf(r,c);
        if(qTable[k]){
          drawArrow(r,c, bestActionIndex(r,c), 0.82);
        }
      }
    }

    // show path for the current episode (trail)
    if(currentPath && currentPath.length>0){
      ctx.lineWidth = Math.max(2, cellPx*0.12);
      ctx.strokeStyle = 'rgba(59,130,246,0.9)';
      ctx.beginPath();
      for(let i=0;i<currentPath.length;i++){
        const p = currentPath[i];
        const x = p.c*cellPx + cellPx*0.5, y = p.r*cellPx + cellPx*0.5;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      // draw small moving particle at last position
      const last = currentPath[currentPath.length-1];
      ctx.fillStyle = '#06b6d4'; ctx.beginPath();
      ctx.arc(last.c*cellPx + cellPx*0.5, last.r*cellPx + cellPx*0.5, Math.max(4, cellPx*0.18), 0, Math.PI*2); ctx.fill();
    }

    // draw start marker
    if(start){
      ctx.fillStyle = '#06b6d4'; ctx.beginPath();
      ctx.arc(start.c*cellPx + cellPx*0.5, start.r*cellPx + cellPx*0.5, Math.max(6,cellPx*0.28), 0, Math.PI*2);
      ctx.fill();
    }

    // final path overlay (if computed)
    if(showFinalPath && showFinalPath.length>0){
      ctx.lineWidth = Math.max(3, cellPx*0.14); ctx.strokeStyle = 'rgba(99,102,241,0.95)';
      ctx.beginPath();
      for(let i=0;i<showFinalPath.length;i++){
        const p = showFinalPath[i];
        const x = p.c*cellPx + cellPx*0.5, y = p.r*cellPx + cellPx*0.5;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      // highlight nodes
      for(const p of showFinalPath){
        ctx.fillStyle = 'rgba(99,102,241,0.95)';
        ctx.beginPath(); ctx.arc(p.c*cellPx + cellPx*0.5, p.r*cellPx + cellPx*0.5, Math.max(3,cellPx*0.12), 0, Math.PI*2); ctx.fill();
      }
    }

    // stats update
    epSpan.textContent = episode;
    stepSpan.textContent = stepCount;
    lastRewardSpan.textContent = lastReward.toFixed(2);
    visitedSpan.textContent = visitedCellsSet.size;
  }

  function drawArrow(r,c, aIdx, alpha=1.0){
    const x = c*cellPx + cellPx*0.5, y = r*cellPx + cellPx*0.5;
    const len = cellPx*0.28;
    const dx = ACTIONS[aIdx].dx * len, dy = ACTIONS[aIdx].dy * len;
    ctx.strokeStyle = `rgba(15,23,42,${alpha})`; ctx.lineWidth = Math.max(1,Math.round(cellPx*0.06));
    ctx.beginPath(); ctx.moveTo(x - dx*0.15, y - dy*0.15); ctx.lineTo(x + dx, y + dy); ctx.stroke();
    ctx.beginPath(); ctx.fillStyle = `rgba(15,23,42,${alpha})`;
    ctx.moveTo(x+dx,y+dy); ctx.lineTo(x + dx - dy*0.18, y + dy + dx*0.18); ctx.lineTo(x + dx + dy*0.18, y + dy - dx*0.18); ctx.closePath(); ctx.fill();
  }

  // ---------- UI interactions ----------
  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const c = Math.floor(x / cellPx), r = Math.floor(y / cellPx);
    if(!inBounds(r,c)) return;
    if(e.button === 2){
      // right-click sets start
      start = {r,c}; render(); return;
    }
    // shift+click sets goal
    if(e.shiftKey){
      // toggle goal
      if(goal && goal.r === r && goal.c === c){ grid[r][c] = 0; goal = null; }
      else { if(grid[r][c] !== 1){ grid[r][c] = 2; goal = {r,c}; } }
      render(); return;
    }
    // left click toggles wall (avoid placing wall on start/goal)
    if(grid[r][c] === 1) grid[r][c] = 0;
    else {
      if(start && start.r===r && start.c===c) return;
      if(goal && goal.r===r && goal.c===c) return;
      grid[r][c] = 1;
    }
    render();
  });

  newGridBtn.addEventListener('click', ()=>{ stopTraining(); initGrid(parseInt(gridSizeInp.value)); });
  clearAllBtn.addEventListener('click', ()=>{
    stopTraining();
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) grid[r][c] = 0;
    start = {r:Math.floor(rows/2), c:Math.floor(cols/2)}; goal = null;
    visitCount = visitCount.map(row=>row.map(()=>0)); qTable = {}; visitedCellsSet.clear(); episode=0; stepCount=0; showFinalPath=[];
    render();
  });

  startBtn.addEventListener('click', ()=>{
    if(!running){
      // start training
      startTraining();
    } else {
      // stop training early
      stopTraining();
    }
  });

  pauseBtn.addEventListener('click', ()=>{
    if(!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  });

  stepBtn.addEventListener('click', ()=>{ if(!running) stepEpisode(); });

  resetQBtn.addEventListener('click', ()=>{
    // fully reset learned state and allow new training immediately
    stopTraining();
    qTable = {};
    visitCount = visitCount.map(row=>row.map(()=>0));
    visitedCellsSet.clear();
    episode = 0; stepCount = 0; lastReward = 0; showFinalPath = [];
    epsilonEl.value = Math.max(parseFloat(epsilonEl.value), 0.02).toFixed(3);
    epSpan.textContent = episode; stepSpan.textContent = stepCount; lastRewardSpan.textContent = lastReward.toFixed(2); visitedSpan.textContent = visitedCellsSet.size;
    render();
  });

  showPathBtn.addEventListener('click', ()=>{ showFinalPath = computeFinalPath(); render(); });

  copyQBtn.addEventListener('click', async ()=>{
    try{
      const obj = {q:qTable};
      const s = JSON.stringify(obj);
      await navigator.clipboard.writeText(s);
      qText.value = s;
      alert('Q-table copied to clipboard.');
    }catch(e){ qText.value = JSON.stringify({q:qTable},null,2); alert('Could not copy automatically; Q JSON placed in text area.'); }
  });

  pasteQBtn.addEventListener('click', async ()=>{
    try{
      const txt = await navigator.clipboard.readText();
      const obj = JSON.parse(txt);
      if(obj && obj.q){ qTable = obj.q; render(); alert('Loaded Q from clipboard.'); qText.value = JSON.stringify(obj,null,2); }
      else alert('Clipboard JSON missing {q:...}');
    }catch(e){ alert('Failed to load JSON from clipboard.'); }
  });

  cellPxInp.addEventListener('change', ()=>{ resizeCanvas(); render(); });
  gridSizeInp.addEventListener('change', ()=>{ stopTraining(); initGrid(parseInt(gridSizeInp.value)); });

  // ---------- boot ----------
  function boot(){
    initGrid(rows);
    // initialize visitCount
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) visitCount[r][c] = 0;
    resizeCanvas();
    render();
  }
  boot();

  // ---------- keyboard shortcuts ----------
  window.addEventListener('keydown', e=>{
    if(e.key === ' ') { if(running){ paused = !paused; pauseBtn.textContent = paused ? 'Resume' : 'Pause'; } }
    if(e.key === 'r') { qTable = {}; visitCount = visitCount.map(row=>row.map(()=>0)); render(); }
    if(e.key === 'p') { showFinalPath = computeFinalPath(); render(); }
  });

  // ---------- done ----------
})();
</script>
</body>
</html>
